#let date = datetime(
  year: 2022,
  month: 3,
  day: 14,
)
#metadata((
  "title": "卡特兰数",
  "author": "dashuai009",
  description: "简单介绍卡特兰数",
  pubDate: "'Jul 08 2022'",
  subtitle: [Catalan,math],
))<frontmatter>

#import "../__template/style.typ": conf
#show: conf


以下搬运自#link("https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0")[wikipedia]

== 卡特兰数
<卡特兰数>
$C_n= 1 / (n+1) binom(2n, n)= (2n)! / ((n+1)!n!),n=1,2,3,...$

== 另一种表示形式
<另一种表示形式>
$C_n= binom(2n, n) - binom(2n, n+1)$

所以，Cn是一个自然数；这一点在先前的通项公式中并不显而易见。

== 递推关系
<递推关系>
$
  C_0 & = 1\
  C_(n + 1) & = sum_(i = 0)^n C_i C_(n - i)
$

$
  C_0 & = 1\
  C_(n + 1) & = frac(2 (2 n + 1), n + 1) C_n
$

== 卡塔兰数的渐近增长
<卡塔兰数的渐近增长>
$C_n tilde.op frac(4^n, n^(3 \/ 2) sqrt(pi))$

== 所有的奇卡塔兰数$C_n$都满足$n = 2^k - 1$。所有其他的卡塔兰数都是偶数。
<所有的奇卡塔兰数c_n都满足displaystyle-n2k-1所有其他的卡塔兰数都是偶数>
== emm
<emm>
$C_n = integral_0^4 x^n frac(1, 2 pi) sqrt(4 / x - 1)$

== 母函数
<母函数>
$
  M (x) & = sum_(n gt.eq 0) C_n X^n\
  & = 1 + sum_(n gt.eq 1) sum_(i = 0)^(n - 1) C_i x^i C_(n - i - 1) x^(n - i - 1) x\
  & = 1 + x sum_(i gt.eq 0) C_i x^i sum_(n gt.eq 0) C_n x^n\
  & = 1 + x M^2 (x)\
  M (x) & = 1 + x M (x)^2\
  M (x) & = frac(2, 1 + sqrt(1 - 4 x)) = frac(1 - sqrt(1 - 4 x), 2 x)
$

生成式的另一个解可以用M(0)特判掉。

== 广义二项式定理
<广义二项式定理>
二项式定理: $(x + y)^n = sum_(k = 0)^n (binom(n, k) x^(n - k) y^k)$,
其中$binom(n, k)$是组合数.

当$n$不是正整数时, $k$无法正好求和到$n$, 因此将一直求和至正无穷,
这样形式上就得到了广义二项式定理:
$(x + y)^alpha = sum_(k = 0)^oo binom(alpha, k) x^(alpha - k) y^k$,
其中$binom(alpha, k) = frac(alpha (alpha - 1) . . . (alpha - k + 1), k !) = frac((alpha)^(underline(k)), k !)$是形式上的组合数.

== 展开形式
<展开形式>
先展开$sqrt(1 - 4 x)$,

$
  (1 - 4 x)^(1 / 2) & = sum_(n gt.eq 0) binom(1 / 2, n) (- 4 x)^n\
  & = 1 + sum_(n gt.eq 1) frac(1 / 2^(underline(n)), n !) (- 4 x)^n\
$

其中，

$
  (1 / 2)^(underline(n)) & = 1 / 2 frac(- 1, 2) frac(- 3, 2) . . . frac(- (2 n - 3), 2)\
  & = frac((- 1)^(n - 1) (2 n - 3) ! !, 2^n)\
  & = frac((- 1)^(n - 1) (2 n - 2) !, 2^n (2 n - 2) ! !)\
  & = frac((- 1)^(n - 1) (2 n - 2) !, 2^(2 n - 1) (n - 1) !)\
$

则

$
  (1 - 4 x)^(1 / 2) & = 1 + sum_(n gt.eq 1) frac((- 1)^(n - 1) (2 n - 2) !, 2^(2 n - 1) (n - 1) ! n !) (- 4 x)^n\
  & = 1 - sum_(n gt.eq 1) frac((2 n - 2) !, (n - 1) ! n !) 2 x^n\
  & = 1 - sum_(n gt.eq 1) binom(2 n - 1, n) frac(1, 2 n - 1) 2 x^n\
$

带回

$
  M (x) & = frac(1 - sqrt(1 - 4 x), 2 x)\
  & = frac(1, 2 x) sum_(n gt.eq 1) binom(2 n - 1, n) frac(1, 2 n - 1) 2 x^n\
  & = sum_(n gt.eq 1) binom(2 n - 1, n) frac(1, 2 n - 1) x^(n - 1)\
  & = sum_(n gt.eq 0) binom(2 n + 1, n + 1) frac(1, 2 n + 1) x^n\
  & = sum_(n gt.eq 0) binom(2 n, n) frac(1, n + 1) x^n
$

即可得到通项公式

== 应用
<应用>
- Cn表示长度2n的dyck
  word\[7\]的个数。Dyck词是一个有n个X和n个Y组成的字串，且所有的前缀字串皆满足X的个数大于等于Y的个数。
- 将上例的X换成左括号，Y换成右括号，Cn表示所有包含n组括号的合法运算式的个数：
- Cn表示有n个节点组成不同构二叉树的方案数。
- Cn表示有2n+1个节点组成不同构满二叉树的方案数。

#strong[证明];：
令1表示进栈，0表示出栈，则可转化为求一个2n位、含n个1、n个0的二进制数，满足从左往右扫描到任意一位时，经过的0数不多于1数。显然含n个1、n个0的2n位二进制数共有$binom(2 n, n)$个，下面考虑不满足要求的数目。

考虑一个含n个1、n个0的2n位二进制数，扫描到第2m+1位上时有m+1个0和m个1（容易证明一定存在这样的情况），则后面的0-1排列中必有n-m个1和n-m-1个0。将2m+2及其以后的部分0变成1、1变成0，则对应一个n+1个0和n-1个1的二进制数。反之亦然（相似的思路证明两者一一对应）。

从而$C_n = binom(2 n, n) - binom(2 n, n + 1) = frac(1, n + 1) binom(2 n, n)$。证毕。

- Cn表示所有在n × n格点中不越过对角线的单调路径的个数。
- Cn表示通过连结顶点而将n + 2边的凸多边形分成三角形的方法个数。
- Cn表示对{1, …, n}依序进出栈的置换个数。一个置换w是依序进出栈的当S(w) =
  (1, …, n),其中S（w）递归定义如下：令w =
  unv，其中n为w的最大元素，u和v为更短的数列；再令S(w) = S(u)S(v)n，其中S
  为所有含一个元素的数列的单位元。
- Cn表示集合{1, …, n}的不交叉划分的个数。那么, Cn永远不大于第n项贝尔数.
  Cn也表示集合{1, …,
  2n}的不交叉划分的个数，其中每个段落的长度为2。综合这两个结论，可以用数学归纳法证明：在
  魏格纳半圆分布定律 中度数大于2的情形下，所有 自由的 累积量s 为零。
  该定律在自由概率论和随机矩阵理论中非常重要。
- Cn表示用n个长方形填充一个高度为n的阶梯状图形的方法个数。
- Cn表示表为2×n的矩阵的标准杨氏矩阵的数量。 也就是说，它是数字 1, 2, …,
  2n
  被放置在一个2×n的矩形中并保证每行每列的数字升序排列的方案数。同样的，该式可由勾长公式的一个特殊情形推导得出。
- Cn表示n个无标号物品的半序的个数。

== 汗科尔矩阵
<汗科尔矩阵>
== 超级卡特兰数（大施罗德数）
<超级卡特兰数大施罗德数>
=== 递推式
<递推式>
$
  & S_1 = 1\
  & forall i gt.eq 2 , s_i = S_(i - 1) + sum_(i = 1)^(n - 1) S_i S_(n - i)
$

=== 生成函数
<生成函数>
$ S (x) = x S (x) + S^2 (x) + x $

解得

$ S (x) = frac(1 - x - sqrt(x^2 - 6 x + 1), 2) $

=== 化简求通向公式
<化简求通向公式>
广义二项式

=== 通项公式
<通项公式>
$ S_n = sum_(i = 1)^n binom(n + i - 1, 2 i) C_i $

=== 一种方法
<一种方法>
接下来给出的一种方法,可以在$O (n k)$的复杂度快速求出$k$次多项式开方后前$n$项的值

设要开方的多项式为$P (x)$,开方后的多项式为$F (x)$.

$ F (x) = P (x)^(1 / 2) = sum_(i = 0)^oo f_i x^i $

两边求导,可得

$ F prime (x) = 1 / 2 P (x)^(- 1 / 2) P prime (x) $

得

$ F (x) P prime (x) = 2 F prime (x) P (x) $

对比每一项系数,不难得到$k + 1$项的递推式.

=== 递推式
<递推式-1>
$ (n + 1) f_(n + 1) = (6 n - 3) f_n - (n - 2) f_(n - 1) $

不过要注意这个递推公式除了第一项其他的项都是超级卡特兰数的$1 / 2$

=== 组合意义
<组合意义>
- $n + 1$边形的任意剖分方案数。#link("http://noi.openjudge.cn/ch0206/9282/")[例题链接]
  还是考虑枚举一条多边形上的边,那么有可能这条边仍然与另一个点拉成一个三角形,也有可能这条边上没有,那么把这两种加起来就是定义的递推式

- 括号序列,每个位置可能左括号,右括号和0.括号对数与0的个数之和为$n - 1$,
  问合法的括号序列数. 同样枚举第一个是左括号还是0.
  值得一提的是,可以看成先插括号再插0,那么枚举括号对数i,0有$n - i - 1$个,需要放入$2 i + 1$个位置中,那么不难得到上面通过广义二项式推出来的式子.

- 从$(0 , 0)$到$(n - 1 , n - 1)$,每次能往右,往上,往右上走,求不超过$y = x$这条直线的方案数.
  枚举第一次是走右上还是走右.
  同样使用容斥思想,把答案转化为从$(0 , 0)$到$(n - 1 , n - 1)$减去(-1,1)到$(n - 1 , n - 1)$.
  那么从$(0 , 0)$到$(n , m)$的路径条数怎么求呢.可以考虑枚举往右上的次数,然后还是考虑先走右和上,然后再把走右上的插入即可.